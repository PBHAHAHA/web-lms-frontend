# ç¬¬åç« ï¼šæ€§èƒ½ä¼˜åŒ–ä¸éƒ¨ç½²

"è¿‡æ—©çš„ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºï¼Œä½†é€‚æ—¶çš„ä¼˜åŒ–æ˜¯æˆåŠŸä¹‹æ¯ã€‚" â€”â€” å”çº³å¾·Â·å…‹åŠªç‰¹ï¼ˆæ”¹ç¼–ï¼‰

åœ¨è½¯ä»¶å¼€å‘çš„ä¸–ç•Œé‡Œï¼Œæ€§èƒ½ä¼˜åŒ–å°±åƒæ˜¯ä¸€é—¨è‰ºæœ¯ã€‚å®ƒä¸ä»…ä»…æ˜¯è®©ä»£ç è·‘å¾—æ›´å¿«ï¼Œæ›´æ˜¯åœ¨ç”¨æˆ·ä½“éªŒã€å¼€å‘æ•ˆç‡å’Œç»´æŠ¤æˆæœ¬ä¹‹é—´æ‰¾åˆ°å®Œç¾çš„å¹³è¡¡ç‚¹ã€‚ä¸€ä¸ªæ€§èƒ½ä¼˜å¼‚çš„åº”ç”¨èƒ½å¤Ÿåœ¨æ¯«ç§’é—´å“åº”ç”¨æˆ·çš„æ¯ä¸€æ¬¡äº¤äº’ï¼Œè®©ç”¨æˆ·æ„Ÿå—åˆ°ä¸èˆ¬é¡ºæ»‘çš„ä½“éªŒã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ç”¨æˆ·ç‚¹å‡»ä¸€ä¸ªæŒ‰é’®æ—¶ï¼Œé¡µé¢ç¬é—´å“åº”ï¼›å½“ä»–ä»¬æ»šåŠ¨åˆ—è¡¨æ—¶ï¼Œå†…å®¹æµç•…åœ°åŠ è½½ï¼›å½“ä»–ä»¬åˆ‡æ¢é¡µé¢æ—¶ï¼Œè½¬åœºåŠ¨ç”»ä¼˜é›…è€Œè‡ªç„¶ã€‚è¿™äº›çœ‹ä¼¼ç®€å•çš„äº¤äº’èƒŒåï¼Œéšè—ç€æ— æ•°çš„æŠ€æœ¯ç»†èŠ‚å’Œä¼˜åŒ–ç­–ç•¥ã€‚

ç°ä»£å‰ç«¯åº”ç”¨é¢ä¸´ç€å‰æ‰€æœªæœ‰çš„å¤æ‚æ€§ï¼šå•é¡µåº”ç”¨çš„ä½“ç§¯è¶Šæ¥è¶Šå¤§ï¼Œç”¨æˆ·å¯¹æ€§èƒ½çš„æœŸæœ›è¶Šæ¥è¶Šé«˜ï¼Œè®¾å¤‡å’Œç½‘ç»œç¯å¢ƒåƒå·®ä¸‡åˆ«ã€‚å¦‚ä½•åœ¨è¿™æ ·çš„ç¯å¢ƒä¸‹æ„å»ºå‡ºæ—¢åŠŸèƒ½ä¸°å¯Œåˆæ€§èƒ½å“è¶Šçš„åº”ç”¨ï¼Œæ˜¯æ¯ä¸ªå‰ç«¯å¼€å‘è€…éƒ½å¿…é¡»é¢å¯¹çš„æŒ‘æˆ˜ã€‚

Nuxt.js ä½œä¸ºä¸€ä¸ªæˆç†Ÿçš„å…¨æ ˆæ¡†æ¶ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†ä¸°å¯Œçš„æ€§èƒ½ä¼˜åŒ–å·¥å…·ï¼šä»è‡ªåŠ¨ä»£ç åˆ†å‰²åˆ°æ™ºèƒ½é¢„åŠ è½½ï¼Œä»æœåŠ¡ç«¯æ¸²æŸ“åˆ°é™æ€ç”Ÿæˆï¼Œä»å›¾ç‰‡ä¼˜åŒ–åˆ°ç¼“å­˜ç­–ç•¥ã€‚æŒæ¡è¿™äº›å·¥å…·ï¼Œå°±åƒæ˜¯æŒæ¡äº†ä¸€æŠŠæŠŠé”‹åˆ©çš„å‰‘ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬åœ¨æ€§èƒ½ä¼˜åŒ–çš„æˆ˜åœºä¸Šæ‰€å‘æŠ«é¡ã€‚

ä»Šå¤©ï¼Œæˆ‘ä»¬å°†è¸ä¸Šæ€§èƒ½ä¼˜åŒ–çš„æœ€åä¸€æ®µæ—…ç¨‹ï¼Œä»å¾®è§‚çš„ä»£ç ä¼˜åŒ–åˆ°å®è§‚çš„æ¶æ„è®¾è®¡ï¼Œä»å¼€å‘ç¯å¢ƒçš„è°ƒè¯•åˆ°ç”Ÿäº§ç¯å¢ƒçš„éƒ¨ç½²ï¼Œå…¨é¢æŒæ¡æ„å»ºé«˜æ€§èƒ½ Web åº”ç”¨çš„æ ¸å¿ƒæŠ€èƒ½ã€‚

## ğŸ¯ æœ¬ç« ç›®æ ‡

- æŒæ¡å‰ç«¯æ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒåŸç†å’Œæœ€ä½³å®è·µ
- å®ç°ä»£ç åˆ†å‰²ã€æ‡’åŠ è½½å’Œé¢„åŠ è½½ç­–ç•¥
- ä¼˜åŒ–å›¾ç‰‡ã€å­—ä½“å’Œé™æ€èµ„æºçš„åŠ è½½
- é…ç½®é«˜æ•ˆçš„ç¼“å­˜ç­–ç•¥å’Œ CDN éƒ¨ç½²
- å®ç°ç”Ÿäº§ç¯å¢ƒçš„ç›‘æ§å’Œæ€§èƒ½åˆ†æ

## âš¡ ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½

### è·¯ç”±çº§ä»£ç åˆ†å‰²

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // å¯ç”¨å®éªŒæ€§åŠŸèƒ½
  experimental: {
    payloadExtraction: false, // ç¦ç”¨ payload æå–ä»¥å‡å°‘åŒ…å¤§å°
  },

  // Vite é…ç½®
  vite: {
    build: {
      // ä»£ç åˆ†å‰²é…ç½®
      rollupOptions: {
        output: {
          // æ‰‹åŠ¨åˆ†åŒ…
          manualChunks: {
            // å°† Vue ç›¸å…³åº“æ‰“åŒ…åˆ°ä¸€èµ·
            vue: ['vue', '@vue/runtime-core', '@vue/runtime-dom'],
            // å°† UI åº“å•ç‹¬æ‰“åŒ…
            ui: ['@headlessui/vue', '@heroicons/vue'],
            // å°†å·¥å…·åº“å•ç‹¬æ‰“åŒ…
            utils: ['lodash-es', 'date-fns', 'validator'],
            // å°†ç¼–è¾‘å™¨ç›¸å…³åº“å•ç‹¬æ‰“åŒ…
            editor: ['@tiptap/core', '@tiptap/starter-kit', '@tiptap/extension-image'],
          },
          // åŠ¨æ€å¯¼å…¥çš„æ–‡ä»¶å‘½å
          chunkFileNames: (chunkInfo) => {
            const facadeModuleId = chunkInfo.facadeModuleId
            if (facadeModuleId) {
              // é¡µé¢ç»„ä»¶
              if (facadeModuleId.includes('/pages/')) {
                return 'pages/[name]-[hash].js'
              }
              // å¸ƒå±€ç»„ä»¶
              if (facadeModuleId.includes('/layouts/')) {
                return 'layouts/[name]-[hash].js'
              }
              // ç»„ä»¶
              if (facadeModuleId.includes('/components/')) {
                return 'components/[name]-[hash].js'
              }
            }
            return 'chunks/[name]-[hash].js'
          },
        },
      },
      // å‹ç¼©é…ç½®
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: true, // ç§»é™¤ console
          drop_debugger: true, // ç§»é™¤ debugger
          pure_funcs: ['console.log'], // ç§»é™¤ç‰¹å®šå‡½æ•°è°ƒç”¨
        },
        mangle: {
          safari10: true, // å…¼å®¹ Safari 10
        },
      },
    },
  },

  // è·¯ç”±é…ç½®
  router: {
    options: {
      // å¯ç”¨è·¯ç”±é¢„åŠ è½½
      linkActiveClass: 'router-link-active',
      linkExactActiveClass: 'router-link-exact-active',
    },
  },

  // æ¸²æŸ“é…ç½®
  ssr: true, // å¯ç”¨ SSR
  
  // é¢„æ¸²æŸ“é…ç½®
  nitro: {
    prerender: {
      // é¢„æ¸²æŸ“è·¯ç”±
      routes: ['/sitemap.xml', '/robots.txt'],
      // çˆ¬å–é“¾æ¥
      crawlLinks: true,
    },
    // å‹ç¼©é…ç½®
    compressPublicAssets: true,
  },
})
```

### ç»„ä»¶çº§æ‡’åŠ è½½

```vue
<!-- components/LazyWrapper.vue -->
<template>
  <div ref="container" class="lazy-wrapper">
    <div v-if="!isVisible && showPlaceholder" class="placeholder">
      <slot name="placeholder">
        <div class="animate-pulse bg-gray-200 rounded h-32"></div>
      </slot>
    </div>
    
    <Suspense v-else-if="isVisible">
      <template #default>
        <component :is="lazyComponent" v-bind="$attrs" />
      </template>
      
      <template #fallback>
        <div class="loading-fallback">
          <slot name="loading">
            <div class="flex items-center justify-center h-32">
              <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
            </div>
          </slot>
        </div>
      </template>
    </Suspense>
  </div>
</template>

<script setup lang="ts">
interface Props {
  component: string | (() => Promise<any>)
  showPlaceholder?: boolean
  rootMargin?: string
  threshold?: number
}

const props = withDefaults(defineProps<Props>(), {
  showPlaceholder: true,
  rootMargin: '50px',
  threshold: 0.1,
})

const container = ref<HTMLElement>()
const isVisible = ref(false)

// æ‡’åŠ è½½ç»„ä»¶
const lazyComponent = computed(() => {
  if (typeof props.component === 'string') {
    return defineAsyncComponent(() => import(`~/components/${props.component}.vue`))
  }
  return defineAsyncComponent(props.component)
})

// Intersection Observer
const { stop } = useIntersectionObserver(
  container,
  ([{ isIntersecting }]) => {
    if (isIntersecting) {
      isVisible.value = true
      stop() // åœæ­¢è§‚å¯Ÿ
    }
  },
  {
    rootMargin: props.rootMargin,
    threshold: props.threshold,
  }
)

onUnmounted(() => {
  stop()
})
</script>
```

### æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥

```typescript
// composables/usePreloader.ts
interface PreloadOptions {
  priority?: 'high' | 'low'
  crossOrigin?: 'anonymous' | 'use-credentials'
  as?: 'script' | 'style' | 'image' | 'font' | 'fetch'
  type?: string
}

interface PreloadItem {
  href: string
  options: PreloadOptions
  loaded: boolean
  loading: boolean
}

export class ResourcePreloader {
  private preloadedResources = new Map<string, PreloadItem>()
  private observer: IntersectionObserver | null = null

  constructor() {
    this.initIntersectionObserver()
  }

  // åˆå§‹åŒ– Intersection Observer
  private initIntersectionObserver() {
    if (process.client) {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const href = entry.target.getAttribute('data-preload-href')
              if (href) {
                this.preloadResource(href)
                this.observer?.unobserve(entry.target)
              }
            }
          })
        },
        {
          rootMargin: '100px',
          threshold: 0.1,
        }
      )
    }
  }

  // é¢„åŠ è½½èµ„æº
  preloadResource(href: string, options: PreloadOptions = {}): Promise<void> {
    return new Promise((resolve, reject) => {
      // æ£€æŸ¥æ˜¯å¦å·²ç»é¢„åŠ è½½
      const existing = this.preloadedResources.get(href)
      if (existing?.loaded) {
        resolve()
        return
      }

      if (existing?.loading) {
        // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œç­‰å¾…å®Œæˆ
        const checkLoaded = () => {
          const item = this.preloadedResources.get(href)
          if (item?.loaded) {
            resolve()
          } else {
            setTimeout(checkLoaded, 10)
          }
        }
        checkLoaded()
        return
      }

      // æ ‡è®°ä¸ºæ­£åœ¨åŠ è½½
      this.preloadedResources.set(href, {
        href,
        options,
        loaded: false,
        loading: true,
      })

      // åˆ›å»ºé¢„åŠ è½½é“¾æ¥
      const link = document.createElement('link')
      link.rel = 'preload'
      link.href = href
      
      if (options.as) link.as = options.as
      if (options.type) link.type = options.type
      if (options.crossOrigin) link.crossOrigin = options.crossOrigin

      link.onload = () => {
        this.preloadedResources.set(href, {
          href,
          options,
          loaded: true,
          loading: false,
        })
        resolve()
      }

      link.onerror = () => {
        this.preloadedResources.delete(href)
        reject(new Error(`Failed to preload ${href}`))
      }

      document.head.appendChild(link)
    })
  }

  // é¢„åŠ è½½å›¾ç‰‡
  preloadImage(src: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const img = new Image()
      img.onload = () => resolve()
      img.onerror = () => reject(new Error(`Failed to preload image ${src}`))
      img.src = src
    })
  }

  // é¢„åŠ è½½å­—ä½“
  preloadFont(href: string, format = 'woff2'): Promise<void> {
    return this.preloadResource(href, {
      as: 'font',
      type: `font/${format}`,
      crossOrigin: 'anonymous',
    })
  }

  // é¢„åŠ è½½ JavaScript æ¨¡å—
  preloadModule(href: string): Promise<void> {
    return this.preloadResource(href, {
      as: 'script',
      crossOrigin: 'anonymous',
    })
  }

  // è§‚å¯Ÿå…ƒç´ è¿›è¡Œé¢„åŠ è½½
  observeElement(element: HTMLElement, href: string) {
    if (this.observer) {
      element.setAttribute('data-preload-href', href)
      this.observer.observe(element)
    }
  }

  // æ‰¹é‡é¢„åŠ è½½
  async preloadBatch(resources: Array<{ href: string; options?: PreloadOptions }>) {
    const promises = resources.map(({ href, options }) => 
      this.preloadResource(href, options).catch(() => {
        // å¿½ç•¥å•ä¸ªèµ„æºçš„åŠ è½½å¤±è´¥
        console.warn(`Failed to preload ${href}`)
      })
    )
    
    await Promise.allSettled(promises)
  }

  // æ¸…ç†èµ„æº
  cleanup() {
    if (this.observer) {
      this.observer.disconnect()
      this.observer = null
    }
    this.preloadedResources.clear()
  }
}

// åˆ›å»ºå…¨å±€é¢„åŠ è½½å™¨å®ä¾‹
export const resourcePreloader = new ResourcePreloader()

// é¢„åŠ è½½ composable
export function usePreloader() {
  const preloadRoute = async (to: string) => {
    try {
      // é¢„åŠ è½½è·¯ç”±ç»„ä»¶
      const route = useRouter().resolve(to)
      if (route.matched.length > 0) {
        const component = route.matched[0].components?.default
        if (component && typeof component === 'function') {
          await component()
        }
      }
    } catch (error) {
      console.warn(`Failed to preload route ${to}:`, error)
    }
  }

  const preloadImages = async (images: string[]) => {
    const promises = images.map(src => resourcePreloader.preloadImage(src))
    await Promise.allSettled(promises)
  }

  const preloadCriticalResources = async () => {
    // é¢„åŠ è½½å…³é”®å­—ä½“
    await resourcePreloader.preloadFont('/fonts/inter-var.woff2')
    
    // é¢„åŠ è½½å…³é”®å›¾ç‰‡
    await preloadImages([
      '/images/hero-bg.webp',
      '/images/logo.svg',
    ])
    
    // é¢„åŠ è½½å…³é”®è·¯ç”±
    await preloadRoute('/courses')
    await preloadRoute('/dashboard')
  }

  return {
    preloadRoute,
    preloadImages,
    preloadCriticalResources,
    preloader: resourcePreloader,
  }
}
```

## ğŸ–¼ï¸ èµ„æºä¼˜åŒ–

### å›¾ç‰‡ä¼˜åŒ–

```typescript
// composables/useImageOptimization.ts
interface ImageOptions {
  width?: number
  height?: number
  quality?: number
  format?: 'webp' | 'avif' | 'jpeg' | 'png'
  fit?: 'cover' | 'contain' | 'fill' | 'inside' | 'outside'
  position?: string
  blur?: number
  sharpen?: boolean
  grayscale?: boolean
}

interface ResponsiveImageOptions extends ImageOptions {
  sizes: Array<{
    width: number
    media?: string
  }>
  fallback?: string
}

export function useImageOptimization() {
  // ç”Ÿæˆä¼˜åŒ–åçš„å›¾ç‰‡ URL
  const getOptimizedImageUrl = (src: string, options: ImageOptions = {}) => {
    const {
      width,
      height,
      quality = 80,
      format = 'webp',
      fit = 'cover',
      position,
      blur,
      sharpen,
      grayscale,
    } = options

    const params = new URLSearchParams()
    
    if (width) params.set('w', width.toString())
    if (height) params.set('h', height.toString())
    if (quality !== 80) params.set('q', quality.toString())
    if (format !== 'webp') params.set('f', format)
    if (fit !== 'cover') params.set('fit', fit)
    if (position) params.set('pos', position)
    if (blur) params.set('blur', blur.toString())
    if (sharpen) params.set('sharpen', 'true')
    if (grayscale) params.set('grayscale', 'true')

    const queryString = params.toString()
    return queryString ? `${src}?${queryString}` : src
  }

  // ç”Ÿæˆå“åº”å¼å›¾ç‰‡æºé›†
  const generateSrcSet = (src: string, options: ResponsiveImageOptions) => {
    const { sizes, ...baseOptions } = options
    
    return sizes
      .map(({ width }) => {
        const url = getOptimizedImageUrl(src, { ...baseOptions, width })
        return `${url} ${width}w`
      })
      .join(', ')
  }

  // ç”Ÿæˆ sizes å±æ€§
  const generateSizes = (options: ResponsiveImageOptions) => {
    return options.sizes
      .map(({ width, media }) => {
        if (media) {
          return `${media} ${width}px`
        }
        return `${width}px`
      })
      .join(', ')
  }

  // æ£€æµ‹ WebP æ”¯æŒ
  const supportsWebP = ref(false)
  const supportsAVIF = ref(false)

  const detectImageFormats = async () => {
    if (process.client) {
      // æ£€æµ‹ WebP æ”¯æŒ
      const webpCanvas = document.createElement('canvas')
      webpCanvas.width = 1
      webpCanvas.height = 1
      supportsWebP.value = webpCanvas.toDataURL('image/webp').indexOf('data:image/webp') === 0

      // æ£€æµ‹ AVIF æ”¯æŒ
      try {
        const avifImage = new Image()
        avifImage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgABogQEAwgMg8f8D///8WfhwB8+ErK42A='
        
        await new Promise((resolve, reject) => {
          avifImage.onload = () => {
            supportsAVIF.value = true
            resolve(true)
          }
          avifImage.onerror = () => {
            supportsAVIF.value = false
            resolve(false)
          }
        })
      } catch {
        supportsAVIF.value = false
      }
    }
  }

  // è·å–æœ€ä½³å›¾ç‰‡æ ¼å¼
  const getBestFormat = (originalFormat?: string) => {
    if (supportsAVIF.value) return 'avif'
    if (supportsWebP.value) return 'webp'
    return originalFormat || 'jpeg'
  }

  // æ‡’åŠ è½½å›¾ç‰‡
  const createLazyImage = (src: string, options: ImageOptions = {}) => {
    const img = ref<HTMLImageElement>()
    const isLoaded = ref(false)
    const isError = ref(false)

    const load = () => {
      if (!img.value) return

      const optimizedSrc = getOptimizedImageUrl(src, {
        ...options,
        format: getBestFormat(options.format),
      })

      const image = new Image()
      image.onload = () => {
        if (img.value) {
          img.value.src = optimizedSrc
          isLoaded.value = true
        }
      }
      image.onerror = () => {
        isError.value = true
      }
      image.src = optimizedSrc
    }

    return {
      img,
      isLoaded: readonly(isLoaded),
      isError: readonly(isError),
      load,
    }
  }

  // åˆå§‹åŒ–
  onMounted(() => {
    detectImageFormats()
  })

  return {
    getOptimizedImageUrl,
    generateSrcSet,
    generateSizes,
    getBestFormat,
    createLazyImage,
    supportsWebP: readonly(supportsWebP),
    supportsAVIF: readonly(supportsAVIF),
  }
}
```

### å­—ä½“ä¼˜åŒ–

```typescript
// composables/useFontOptimization.ts
interface FontFace {
  family: string
  src: string[]
  weight?: string | number
  style?: string
  display?: 'auto' | 'block' | 'swap' | 'fallback' | 'optional'
  unicodeRange?: string
}

export function useFontOptimization() {
  const loadedFonts = new Set<string>()

  // é¢„åŠ è½½å­—ä½“
  const preloadFont = async (fontFace: FontFace) => {
    const fontKey = `${fontFace.family}-${fontFace.weight}-${fontFace.style}`
    
    if (loadedFonts.has(fontKey)) {
      return
    }

    try {
      // ä½¿ç”¨ CSS Font Loading API
      if ('fonts' in document) {
        const font = new FontFace(
          fontFace.family,
          `url(${fontFace.src[0]})`,
          {
            weight: fontFace.weight?.toString() || 'normal',
            style: fontFace.style || 'normal',
            display: fontFace.display || 'swap',
            unicodeRange: fontFace.unicodeRange,
          }
        )

        await font.load()
        document.fonts.add(font)
        loadedFonts.add(fontKey)
      } else {
        // é™çº§æ–¹æ¡ˆï¼šåˆ›å»ºéšè—å…ƒç´ è§¦å‘å­—ä½“åŠ è½½
        const testElement = document.createElement('div')
        testElement.style.fontFamily = fontFace.family
        testElement.style.fontSize = '1px'
        testElement.style.opacity = '0'
        testElement.style.position = 'absolute'
        testElement.style.top = '-9999px'
        testElement.textContent = 'Font loading test'
        
        document.body.appendChild(testElement)
        
        // ç­‰å¾…å­—ä½“åŠ è½½
        await new Promise(resolve => setTimeout(resolve, 100))
        
        document.body.removeChild(testElement)
        loadedFonts.add(fontKey)
      }
    } catch (error) {
      console.warn(`Failed to load font ${fontFace.family}:`, error)
    }
  }

  // æ‰¹é‡é¢„åŠ è½½å­—ä½“
  const preloadFonts = async (fonts: FontFace[]) => {
    const promises = fonts.map(font => preloadFont(font))
    await Promise.allSettled(promises)
  }

  // å­—ä½“æ˜¾ç¤ºä¼˜åŒ–
  const optimizeFontDisplay = () => {
    if (process.client) {
      // æ·»åŠ å­—ä½“æ˜¾ç¤º CSS
      const style = document.createElement('style')
      style.textContent = `
        @font-face {
          font-family: 'Inter';
          font-style: normal;
          font-weight: 100 900;
          font-display: swap;
          src: url('/fonts/inter-var.woff2') format('woff2');
          unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }
        
        /* å­—ä½“åŠ è½½æœŸé—´çš„é™çº§å­—ä½“ */
        .font-loading {
          font-family: system-ui, -apple-system, sans-serif;
        }
        
        /* å­—ä½“åŠ è½½å®Œæˆåçš„æ ·å¼ */
        .font-loaded {
          font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
      `
      document.head.appendChild(style)
    }
  }

  // ç›‘å¬å­—ä½“åŠ è½½çŠ¶æ€
  const watchFontLoading = () => {
    if (process.client && 'fonts' in document) {
      document.fonts.ready.then(() => {
        document.documentElement.classList.add('fonts-loaded')
        document.documentElement.classList.remove('fonts-loading')
      })

      // ç›‘å¬å•ä¸ªå­—ä½“åŠ è½½
      document.fonts.addEventListener('loadingdone', (event) => {
        console.log('Fonts loaded:', event)
      })

      document.fonts.addEventListener('loadingerror', (event) => {
        console.warn('Font loading error:', event)
      })
    }
  }

  // å­—ä½“å­é›†åŒ–
  const createFontSubset = (text: string, fontFamily: string) => {
    // è·å–æ–‡æœ¬ä¸­ä½¿ç”¨çš„å­—ç¬¦
    const usedChars = new Set(text)
    const unicodeRanges: string[] = []

    usedChars.forEach(char => {
      const codePoint = char.codePointAt(0)
      if (codePoint) {
        unicodeRanges.push(`U+${codePoint.toString(16).toUpperCase()}`)
      }
    })

    return {
      fontFamily,
      unicodeRange: unicodeRanges.join(', '),
    }
  }

  return {
    preloadFont,
    preloadFonts,
    optimizeFontDisplay,
    watchFontLoading,
    createFontSubset,
    loadedFonts: readonly(loadedFonts),
  }
}
```

## ğŸš€ æ„å»ºä¼˜åŒ–

### Webpack/Vite ä¼˜åŒ–é…ç½®

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  // æ„å»ºä¼˜åŒ–
  build: {
    // åˆ†æåŒ…å¤§å°
    analyze: process.env.ANALYZE === 'true',
  },

  vite: {
    build: {
      // ç›®æ ‡ç¯å¢ƒ
      target: 'es2015',
      
      // å‹ç¼©é…ç½®
      minify: 'terser',
      terserOptions: {
        compress: {
          // ç§»é™¤ console å’Œ debugger
          drop_console: process.env.NODE_ENV === 'production',
          drop_debugger: true,
          // ç§»é™¤æœªä½¿ç”¨çš„ä»£ç 
          pure_funcs: ['console.log', 'console.info', 'console.debug'],
          // ç§»é™¤æ³¨é‡Š
          comments: false,
        },
        mangle: {
          // ä¿ç•™ç±»åï¼ˆç”¨äºè°ƒè¯•ï¼‰
          keep_classnames: process.env.NODE_ENV !== 'production',
          // Safari 10 å…¼å®¹æ€§
          safari10: true,
        },
        format: {
          // ç§»é™¤æ³¨é‡Š
          comments: false,
        },
      },

      // ä»£ç åˆ†å‰²
      rollupOptions: {
        output: {
          // æ‰‹åŠ¨åˆ†åŒ…ç­–ç•¥
          manualChunks: (id) => {
            // ç¬¬ä¸‰æ–¹åº“
            if (id.includes('node_modules')) {
              // Vue ç”Ÿæ€
              if (id.includes('vue') || id.includes('@vue')) {
                return 'vue-vendor'
              }
              // UI åº“
              if (id.includes('@headlessui') || id.includes('@heroicons')) {
                return 'ui-vendor'
              }
              // å·¥å…·åº“
              if (id.includes('lodash') || id.includes('date-fns') || id.includes('validator')) {
                return 'utils-vendor'
              }
              // ç¼–è¾‘å™¨
              if (id.includes('@tiptap') || id.includes('prosemirror')) {
                return 'editor-vendor'
              }
              // å…¶ä»–ç¬¬ä¸‰æ–¹åº“
              return 'vendor'
            }
            
            // é¡µé¢ç»„ä»¶
            if (id.includes('/pages/')) {
              return 'pages'
            }
            
            // ç»„ä»¶
            if (id.includes('/components/')) {
              return 'components'
            }
          },
          
          // æ–‡ä»¶å‘½å
          chunkFileNames: (chunkInfo) => {
            const name = chunkInfo.name || 'chunk'
            return `js/${name}-[hash].js`
          },
          entryFileNames: 'js/[name]-[hash].js',
          assetFileNames: (assetInfo) => {
            const name = assetInfo.name || 'asset'
            const ext = name.split('.').pop()
            
            if (['css'].includes(ext!)) {
              return 'css/[name]-[hash].[ext]'
            }
            if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'avif'].includes(ext!)) {
              return 'images/[name]-[hash].[ext]'
            }
            if (['woff', 'woff2', 'ttf', 'eot'].includes(ext!)) {
              return 'fonts/[name]-[hash].[ext]'
            }
            
            return 'assets/[name]-[hash].[ext]'
          },
        },
      },

      // èµ„æºå†…è”é˜ˆå€¼
      assetsInlineLimit: 4096, // 4KB ä»¥ä¸‹çš„èµ„æºå†…è”

      // CSS ä»£ç åˆ†å‰²
      cssCodeSplit: true,

      // æºç æ˜ å°„
      sourcemap: process.env.NODE_ENV !== 'production',
    },

    // å¼€å‘æœåŠ¡å™¨ä¼˜åŒ–
    server: {
      // é¢„çƒ­å¸¸ç”¨æ–‡ä»¶
      warmup: {
        clientFiles: [
          './components/**/*.vue',
          './pages/**/*.vue',
          './layouts/**/*.vue',
        ],
      },
    },

    // ä¾èµ–ä¼˜åŒ–
    optimizeDeps: {
      include: [
        'vue',
        '@vue/runtime-core',
        '@vue/runtime-dom',
        '@vueuse/core',
        'pinia',
      ],
      exclude: [
        // æ’é™¤å¤§å‹åº“ï¼Œè®©å®ƒä»¬ä¿æŒåŠ¨æ€å¯¼å…¥
        '@tiptap/core',
        '@tiptap/starter-kit',
      ],
    },

    // æ’ä»¶é…ç½®
    plugins: [
      // å‹ç¼©æ’ä»¶
      process.env.NODE_ENV === 'production' && {
        name: 'compression',
        generateBundle(options, bundle) {
          // è¿™é‡Œå¯ä»¥æ·»åŠ è‡ªå®šä¹‰å‹ç¼©é€»è¾‘
        },
      },
    ].filter(Boolean),
  },

  // CSS ä¼˜åŒ–
  css: {
    // PostCSS é…ç½®
    postcss: {
      plugins: {
        // è‡ªåŠ¨æ·»åŠ æµè§ˆå™¨å‰ç¼€
        autoprefixer: {},
        // å‹ç¼© CSS
        cssnano: process.env.NODE_ENV === 'production' ? {
          preset: ['default', {
            discardComments: { removeAll: true },
            normalizeWhitespace: true,
          }],
        } : false,
        // ç§»é™¤æœªä½¿ç”¨çš„ CSS
        '@fullhuman/postcss-purgecss': process.env.NODE_ENV === 'production' ? {
          content: [
            './components/**/*.{vue,js,ts}',
            './layouts/**/*.vue',
            './pages/**/*.vue',
            './plugins/**/*.{js,ts}',
            './app.vue',
          ],
          safelist: [
            // ä¿ç•™åŠ¨æ€ç±»å
            /^nuxt-/,
            /^router-/,
            /^transition-/,
            // ä¿ç•™ç¬¬ä¸‰æ–¹åº“çš„ç±»å
            /^tiptap-/,
            /^ProseMirror/,
          ],
        } : false,
      },
    },
  },

  // å®éªŒæ€§åŠŸèƒ½
  experimental: {
    // å¯ç”¨ Vite çš„æ–°åŠŸèƒ½
    viteNode: true,
    // å‡å°‘ payload å¤§å°
    payloadExtraction: false,
    // å†…è”æ ·å¼
    inlineSSRStyles: true,
  },
})
```

### æ€§èƒ½ç›‘æ§

```typescript
// plugins/performance.client.ts
interface PerformanceMetrics {
  // Core Web Vitals
  FCP?: number // First Contentful Paint
  LCP?: number // Largest Contentful Paint
  FID?: number // First Input Delay
  CLS?: number // Cumulative Layout Shift
  TTFB?: number // Time to First Byte
  
  // è‡ªå®šä¹‰æŒ‡æ ‡
  TTI?: number // Time to Interactive
  TBT?: number // Total Blocking Time
  SI?: number // Speed Index
  
  // èµ„æºåŠ è½½
  resourceLoadTime?: Record<string, number>
  
  // ç”¨æˆ·äº¤äº’
  userInteractions?: Array<{
    type: string
    timestamp: number
    duration?: number
  }>
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {}
  private observer: PerformanceObserver | null = null

  constructor() {
    this.initPerformanceObserver()
    this.measureCoreWebVitals()
    this.measureCustomMetrics()
  }

  // åˆå§‹åŒ–æ€§èƒ½è§‚å¯Ÿå™¨
  private initPerformanceObserver() {
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.processPerformanceEntry(entry)
        }
      })

      // è§‚å¯Ÿä¸åŒç±»å‹çš„æ€§èƒ½æ¡ç›®
      try {
        this.observer.observe({ entryTypes: ['navigation', 'resource', 'paint', 'largest-contentful-paint', 'first-input', 'layout-shift'] })
      } catch (error) {
        console.warn('Performance observer not supported:', error)
      }
    }
  }

  // å¤„ç†æ€§èƒ½æ¡ç›®
  private processPerformanceEntry(entry: PerformanceEntry) {
    switch (entry.entryType) {
      case 'navigation':
        this.processNavigationEntry(entry as PerformanceNavigationTiming)
        break
      case 'resource':
        this.processResourceEntry(entry as PerformanceResourceTiming)
        break
      case 'paint':
        this.processPaintEntry(entry as PerformancePaintTiming)
        break
      case 'largest-contentful-paint':
        this.processLCPEntry(entry as any)
        break
      case 'first-input':
        this.processFIDEntry(entry as any)
        break
      case 'layout-shift':
        this.processCLSEntry(entry as any)
        break
    }
  }

  // å¤„ç†å¯¼èˆªæ€§èƒ½
  private processNavigationEntry(entry: PerformanceNavigationTiming) {
    this.metrics.TTFB = entry.responseStart - entry.requestStart
  }

  // å¤„ç†èµ„æºåŠ è½½æ€§èƒ½
  private processResourceEntry(entry: PerformanceResourceTiming) {
    if (!this.metrics.resourceLoadTime) {
      this.metrics.resourceLoadTime = {}
    }
    
    const resourceName = entry.name.split('/').pop() || entry.name
    this.metrics.resourceLoadTime[resourceName] = entry.duration
  }

  // å¤„ç†ç»˜åˆ¶æ€§èƒ½
  private processPaintEntry(entry: PerformancePaintTiming) {
    if (entry.name === 'first-contentful-paint') {
      this.metrics.FCP = entry.startTime
    }
  }

  // å¤„ç† LCP
  private processLCPEntry(entry: any) {
    this.metrics.LCP = entry.startTime
  }

  // å¤„ç† FID
  private processFIDEntry(entry: any) {
    this.metrics.FID = entry.processingStart - entry.startTime
  }

  // å¤„ç† CLS
  private processCLSEntry(entry: any) {
    if (!this.metrics.CLS) {
      this.metrics.CLS = 0
    }
    this.metrics.CLS += entry.value
  }

  // æµ‹é‡ Core Web Vitals
  private measureCoreWebVitals() {
    // ä½¿ç”¨ web-vitals åº“çš„ç®€åŒ–ç‰ˆæœ¬
    this.measureLCP()
    this.measureFID()
    this.measureCLS()
  }

  // æµ‹é‡ LCP
  private measureLCP() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const lastEntry = entries[entries.length - 1] as any
        this.metrics.LCP = lastEntry.startTime
      })

      try {
        observer.observe({ entryTypes: ['largest-contentful-paint'] })
      } catch (error) {
        console.warn('LCP measurement not supported')
      }
    }
  }

  // æµ‹é‡ FID
  private measureFID() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries()
        entries.forEach((entry: any) => {
          this.metrics.FID = entry.processingStart - entry.startTime
        })
      })

      try {
        observer.observe({ entryTypes: ['first-input'] })
      } catch (error) {
        console.warn('FID measurement not supported')
      }
    }
  }

  // æµ‹é‡ CLS
  private measureCLS() {
    if ('PerformanceObserver' in window) {
      let clsValue = 0
      
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries()
        entries.forEach((entry: any) => {
          if (!entry.hadRecentInput) {
            clsValue += entry.value
            this.metrics.CLS = clsValue
          }
        })
      })

      try {
        observer.observe({ entryTypes: ['layout-shift'] })
      } catch (error) {
        console.warn('CLS measurement not supported')
      }
    }
  }

  // æµ‹é‡è‡ªå®šä¹‰æŒ‡æ ‡
  private measureCustomMetrics() {
    // TTI (Time to Interactive)
    this.measureTTI()
    
    // ç”¨æˆ·äº¤äº’ç›‘æ§
    this.monitorUserInteractions()
  }

  // æµ‹é‡ TTI
  private measureTTI() {
    // ç®€åŒ–çš„ TTI è®¡ç®—
    const checkTTI = () => {
      if (document.readyState === 'complete') {
        this.metrics.TTI = performance.now()
      } else {
        setTimeout(checkTTI, 100)
      }
    }
    
    if (document.readyState === 'complete') {
      this.metrics.TTI = performance.now()
    } else {
      document.addEventListener('readystatechange', checkTTI)
    }
  }

  // ç›‘æ§ç”¨æˆ·äº¤äº’
  private monitorUserInteractions() {
    if (!this.metrics.userInteractions) {
      this.metrics.userInteractions = []
    }

    const interactionTypes = ['click', 'keydown', 'scroll', 'touchstart']
    
    interactionTypes.forEach(type => {
      document.addEventListener(type, (event) => {
        this.metrics.userInteractions!.push({
          type,
          timestamp: performance.now(),
        })
      }, { passive: true })
    })
  }

  // è·å–æ€§èƒ½æŠ¥å‘Š
  getPerformanceReport(): PerformanceMetrics {
    return { ...this.metrics }
  }

  // å‘é€æ€§èƒ½æ•°æ®
  async sendPerformanceData() {
    const report = this.getPerformanceReport()
    
    try {
      // å‘é€åˆ°åˆ†ææœåŠ¡
      await $fetch('/api/analytics/performance', {
        method: 'POST',
        body: {
          url: window.location.href,
          userAgent: navigator.userAgent,
          timestamp: Date.now(),
          metrics: report,
        },
      })
    } catch (error) {
      console.warn('Failed to send performance data:', error)
    }
  }

  // æ¸…ç†èµ„æº
  cleanup() {
    if (this.observer) {
      this.observer.disconnect()
      this.observer = null
    }
  }
}

// åˆ›å»ºæ€§èƒ½ç›‘æ§å®ä¾‹
const performanceMonitor = new PerformanceMonitor()

// é¡µé¢å¸è½½æ—¶å‘é€æ•°æ®
window.addEventListener('beforeunload', () => {
  performanceMonitor.sendPerformanceData()
})

// é¡µé¢éšè—æ—¶å‘é€æ•°æ®
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') {
    performanceMonitor.sendPerformanceData()
  }
})

export default defineNuxtPlugin(() => {
  // æä¾›æ€§èƒ½ç›‘æ§å®ä¾‹
  return {
    provide: {
      performanceMonitor,
    },
  }
})
```

## ğŸŒ éƒ¨ç½²ä¼˜åŒ–

### Docker éƒ¨ç½²é…ç½®

```dockerfile
# Dockerfile
# å¤šé˜¶æ®µæ„å»º
FROM node:18-alpine AS base

# å®‰è£… pnpm
RUN npm install -g pnpm

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ package æ–‡ä»¶
COPY package.json pnpm-lock.yaml ./

# ä¾èµ–å®‰è£…é˜¶æ®µ
FROM base AS deps
RUN pnpm install --frozen-lockfile

# æ„å»ºé˜¶æ®µ
FROM base AS builder
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# æ„å»ºåº”ç”¨
ENV NODE_ENV=production
RUN pnpm build

# ç”Ÿäº§è¿è¡Œé˜¶æ®µ
FROM node:18-alpine AS runner

# åˆ›å»ºé root ç”¨æˆ·
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nuxtjs

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶æ„å»ºäº§ç‰©
COPY --from=builder --chown=nuxtjs:nodejs /app/.output ./

# åˆ‡æ¢åˆ°é root ç”¨æˆ·
USER nuxtjs

# æš´éœ²ç«¯å£
EXPOSE 3000

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV NODE_ENV=production
ENV NUXT_HOST=0.0.0.0
ENV NUXT_PORT=3000

# å¯åŠ¨åº”ç”¨
CMD ["node", "server/index.mjs"]
```

### Nginx é…ç½®

```nginx
# nginx.conf
upstream nuxt_app {
    server app:3000;
    keepalive 32;
}

server {
    listen 80;
    server_name your-domain.com;
    
    # é‡å®šå‘åˆ° HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;

    # SSL é…ç½®
    ssl_certificate /etc/ssl/certs/your-domain.crt;
    ssl_certificate_key /etc/ssl/private/your-domain.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # å®‰å…¨å¤´
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin";

    # Gzip å‹ç¼©
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Brotli å‹ç¼©
    brotli on;
    brotli_comp_level 6;
    brotli_types
        text/plain
        text/css
        application/json
        application/javascript
        text/xml
        application/xml
        application/xml+rss
        text/javascript;

    # é™æ€èµ„æºç¼“å­˜
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Vary "Accept-Encoding";
        
        # é¢„å‹ç¼©æ–‡ä»¶
        location ~* \.(js|css)$ {
            gzip_static on;
            brotli_static on;
        }
    }

    # API è·¯ç”±
    location /api/ {
        proxy_pass http://nuxt_app;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # è¶…æ—¶è®¾ç½®
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }

    # ä¸»åº”ç”¨
    location / {
        proxy_pass http://nuxt_app;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # ç¼“å­˜ HTML
        proxy_cache html_cache;
        proxy_cache_valid 200 5m;
        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
        proxy_cache_lock on;
        
        # è¶…æ—¶è®¾ç½®
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }

    # å¥åº·æ£€æŸ¥
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}

# ç¼“å­˜é…ç½®
proxy_cache_path /var/cache/nginx/html levels=1:2 keys_zone=html_cache:10m max_size=100m inactive=60m use_temp_path=off;
```

### CI/CD é…ç½®

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: latest

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linting
        run: pnpm lint

      - name: Run type checking
        run: pnpm type-check

      - name: Run tests
        run: pnpm test

      - name: Build application
        run: pnpm build

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    environment:
      name: production
      url: https://your-domain.com

    steps:
      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            # æ‹‰å–æœ€æ–°é•œåƒ
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            
            # åœæ­¢æ—§å®¹å™¨
            docker stop nuxt-app || true
            docker rm nuxt-app || true
            
            # å¯åŠ¨æ–°å®¹å™¨
            docker run -d \
              --name nuxt-app \
              --restart unless-stopped \
              -p 3000:3000 \
              -e NODE_ENV=production \
              -e DATABASE_URL=${{ secrets.DATABASE_URL }} \
              -e JWT_SECRET=${{ secrets.JWT_SECRET }} \
              ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            
            # æ¸…ç†æ—§é•œåƒ
            docker image prune -f

      - name: Health check
        run: |
          sleep 30
          curl -f https://your-domain.com/health || exit 1
```

## ğŸ§ª å®è·µç»ƒä¹ 

1. **æ€§èƒ½å®¡è®¡**
   - ä½¿ç”¨ Lighthouse è¿›è¡Œæ€§èƒ½æµ‹è¯•
   - åˆ†æ Core Web Vitals æŒ‡æ ‡
   - åˆ¶å®šæ€§èƒ½ä¼˜åŒ–è®¡åˆ’

2. **ç¼“å­˜ç­–ç•¥å®ç°**
   - é…ç½®å¤šå±‚ç¼“å­˜
   - å®ç°ç¼“å­˜å¤±æ•ˆæœºåˆ¶
   - ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡

3. **éƒ¨ç½²æµæ°´çº¿æ­å»º**
   - è®¾ç½®è‡ªåŠ¨åŒ–æµ‹è¯•
   - é…ç½®è“ç»¿éƒ¨ç½²
   - å®ç°å›æ»šæœºåˆ¶

## ğŸ’­ æ€è€ƒé¢˜

1. **å¦‚ä½•å¹³è¡¡æ€§èƒ½å’ŒåŠŸèƒ½ï¼Ÿ**
   - æ€§èƒ½é¢„ç®—åˆ¶å®š
   - åŠŸèƒ½ä¼˜å…ˆçº§è¯„ä¼°
   - æ¸è¿›å¼å¢å¼ºç­–ç•¥

2. **å¦‚ä½•å¤„ç†ä¸åŒç½‘ç»œç¯å¢ƒï¼Ÿ**
   - è‡ªé€‚åº”åŠ è½½ç­–ç•¥
   - ç¦»çº¿åŠŸèƒ½è®¾è®¡
   - ç½‘ç»œçŠ¶æ€æ£€æµ‹

3. **å¦‚ä½•ç›‘æ§ç”Ÿäº§ç¯å¢ƒæ€§èƒ½ï¼Ÿ**
   - å®æ—¶æ€§èƒ½ç›‘æ§
   - é”™è¯¯è¿½è¸ªç³»ç»Ÿ
   - ç”¨æˆ·ä½“éªŒåˆ†æ

## ğŸ‰ å°ç»“

é€šè¿‡è¿™ä¸€ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å®Œæˆäº†ä»å¼€å‘åˆ°éƒ¨ç½²çš„å®Œæ•´æ€§èƒ½ä¼˜åŒ–æµç¨‹ã€‚ä»ä»£ç åˆ†å‰²åˆ°èµ„æºä¼˜åŒ–ï¼Œä»æ„å»ºé…ç½®åˆ°éƒ¨ç½²ç­–ç•¥ï¼Œæˆ‘ä»¬æŒæ¡äº†æ„å»ºé«˜æ€§èƒ½ Web åº”ç”¨çš„å…¨å¥—æŠ€èƒ½ã€‚

æˆ‘ä»¬å­¦åˆ°äº†ï¼š
- âœ… ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½çš„æœ€ä½³å®è·µ
- âœ… å›¾ç‰‡ã€å­—ä½“ç­‰èµ„æºçš„ä¼˜åŒ–ç­–ç•¥
- âœ… æ„å»ºå·¥å…·çš„é«˜çº§é…ç½®å’Œä¼˜åŒ–
- âœ… æ€§èƒ½ç›‘æ§å’Œåˆ†æç³»ç»Ÿ
- âœ… ç”Ÿäº§ç¯å¢ƒçš„éƒ¨ç½²å’Œè¿ç»´

æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦æˆ‘ä»¬åœ¨å¼€å‘çš„æ¯ä¸ªé˜¶æ®µéƒ½ä¿æŒæ€§èƒ½æ„è¯†ã€‚ä¸€ä¸ªä¼˜ç§€çš„åº”ç”¨ä¸ä»…è¦åŠŸèƒ½å®Œå–„ï¼Œæ›´è¦åœ¨å„ç§ç¯å¢ƒä¸‹éƒ½èƒ½æä¾›æµç•…çš„ç”¨æˆ·ä½“éªŒã€‚

## ğŸ“ æ•™ç¨‹æ€»ç»“

æ­å–œä½ å®Œæˆäº†è¿™ä¸ªå…¨é¢çš„ Nuxt.js å­¦ä¹ ä¹‹æ—…ï¼ä»é¡¹ç›®åˆå§‹åŒ–åˆ°ç”Ÿäº§éƒ¨ç½²ï¼Œæˆ‘ä»¬ä¸€èµ·æ¢ç´¢äº†ç°ä»£å‰ç«¯å¼€å‘çš„æ–¹æ–¹é¢é¢ï¼š

1. **é¡¹ç›®åŸºç¡€** - æ­å»ºäº†åšå®çš„å¼€å‘ç¯å¢ƒ
2. **é…ç½®ç³»ç»Ÿ** - æŒæ¡äº† Nuxt.js çš„æ ¸å¿ƒé…ç½®
3. **UI ç³»ç»Ÿ** - æ„å»ºäº†ç¾è§‚ä¸”å¯ç»´æŠ¤çš„ç•Œé¢
4. **è·¯ç”±å¸ƒå±€** - å®ç°äº†çµæ´»çš„é¡µé¢ç»“æ„
5. **ç”¨æˆ·è®¤è¯** - å»ºç«‹äº†å®‰å…¨çš„èº«ä»½éªŒè¯ç³»ç»Ÿ
6. **è¯¾ç¨‹ç®¡ç†** - å¼€å‘äº†å®Œæ•´çš„ä¸šåŠ¡åŠŸèƒ½
7. **å¯Œæ–‡æœ¬ç¼–è¾‘** - é›†æˆäº†å¼ºå¤§çš„å†…å®¹ç¼–è¾‘å™¨
8. **çŠ¶æ€ç®¡ç†** - æ„å»ºäº†å¯æ‰©å±•çš„æ•°æ®æµ
9. **API é›†æˆ** - å®ç°äº†é«˜æ•ˆçš„æ•°æ®äº¤äº’
10. **æ€§èƒ½ä¼˜åŒ–** - æ‰“é€ äº†ç”Ÿäº§çº§çš„åº”ç”¨æ€§èƒ½

è¿™ä¸ªå­¦ä¹ ç®¡ç†ç³»ç»Ÿä¸ä»…æ˜¯ä¸€ä¸ªå®Œæ•´çš„é¡¹ç›®ï¼Œæ›´æ˜¯ç°ä»£å‰ç«¯å¼€å‘æœ€ä½³å®è·µçš„é›†åˆã€‚å¸Œæœ›è¿™ä¸ªæ•™ç¨‹èƒ½å¤Ÿå¸®åŠ©ä½ åœ¨å‰ç«¯å¼€å‘çš„é“è·¯ä¸Šèµ°å¾—æ›´è¿œï¼Œåˆ›é€ å‡ºæ›´å¤šä¼˜ç§€çš„åº”ç”¨ï¼

è®°ä½ï¼ŒæŠ€æœ¯åœ¨ä¸æ–­å‘å±•ï¼Œä¿æŒå­¦ä¹ çš„çƒ­æƒ…å’Œå¥½å¥‡å¿ƒï¼Œæ°¸è¿œæ˜¯æˆä¸ºä¼˜ç§€å¼€å‘è€…çš„å…³é”®ã€‚åŠ æ²¹ï¼ğŸš€